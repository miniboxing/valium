warning: 'valium' selects 6 phases
[Now checking: valium-prepare]
[Now checking: valium-verify]
[Now checking: valium-addext]
[Now checking: valium-inject]
[Not checkable: valium-coerce]
[[syntax trees at end of             valium-commit]] // newSource1.scala
package valium.testcases.multipoly {
  @value final class Point[T] extends Object {
    <paramaccessor> private[this] val x: T = _;
    <stable> <accessor> <paramaccessor> def x(): T = Point.this.x;
    <paramaccessor> private[this] val y: T = _;
    <stable> <accessor> <paramaccessor> def y(): T = Point.this.y;
    def <init>(x: T, y: T): valium.testcases.multipoly.Point[T] = {
      Point.super.<init>();
      ()
    };
    override def toString(): String = {
      <synthetic> val $$4: valium.testcases.multipoly.Point[T] = Point.this;
      <synthetic> val 1$x: T = $$4.x;
      <synthetic> val 1$y: T = $$4.y;
      <synthetic> val this$x$2: T = 1$x;
      <synthetic> val this$y$3: T = 1$y;
      multipoly.this.Point.toString$xtension[T](this$x$2, this$y$3)
    };
    override def hashCode(): Int = {
      <synthetic> val $$8: valium.testcases.multipoly.Point[T] = Point.this;
      <synthetic> val 5$x: T = $$8.x;
      <synthetic> val 5$y: T = $$8.y;
      <synthetic> val this$x$6: T = 5$x;
      <synthetic> val this$y$7: T = 5$y;
      multipoly.this.Point.hashCode$xtension[T](this$x$6, this$y$7)
    };
    override def equals(other: Any): Boolean = {
      <synthetic> val $$13: valium.testcases.multipoly.Point[T] = Point.this;
      <synthetic> val 9$x: T = $$13.x;
      <synthetic> val 9$y: T = $$13.y;
      <synthetic> val this$x$10: T = 9$x;
      <synthetic> val this$y$11: T = 9$y;
      <synthetic> val 12: Any = other;
      multipoly.this.Point.equals$xtension[T](this$x$10, this$y$11, 12)
    }
  };
  <synthetic> object Point extends Object {
    def <init>(): valium.testcases.multipoly.Point.type = {
      Point.super.<init>();
      ()
    };
    final def toString$xtension[T]($this$x: T, $this$y: T): String = {
      <synthetic> val p1$x: T = $this$x;
      <synthetic> val p1$y: T = $this$y;
      new StringContext(scala.this.Predef.wrapRefArray[String](Array[String]{"Point(", ", ", ")"})).s(scala.this.Predef.genericWrapArray[Any](Array[Any]{$this$x, $this$y}))
    };
    final def hashCode$xtension[T]($this$x: T, $this$y: T): Int = $this$x.hashCode();
    final def equals$xtension[T]($this$x: T, $this$y: T, other: Any): Boolean = other.isInstanceOf[valium.testcases.multipoly.Point[T]]().&&(other.asInstanceOf[valium.testcases.multipoly.Point[T]]().x().==($this$x)).&&(other.asInstanceOf[valium.testcases.multipoly.Point[T]]().y().==($this$y))
  };
  object Test extends Object {
    def <init>(): valium.testcases.multipoly.Test.type = {
      Test.super.<init>();
      ()
    };
    def main(args: Array[String]): Unit = {
      def identitymono(p1$x: Double, p1$y: Double): valium.testcases.multipoly.Point[Double] = {
        <synthetic> val p2$x: Double = p1$x;
        <synthetic> val p2$y: Double = p1$y;
        def p3(): valium.testcases.multipoly.Point[Double] = new valium.testcases.multipoly.Point[Double](p2$x, p2$y);
        scala.this.Predef.println(new valium.testcases.multipoly.Point[Double](p2$x, p2$y));
        scala.this.Predef.println(Point.this.toString$xtension[Double](p2$x, p2$y));
        <synthetic> val $$16: valium.testcases.multipoly.Point[Double] = {
          <synthetic> val $$20: valium.testcases.multipoly.Point[Double] = p3();
          <synthetic> val 17$x: Double = $$20.x;
          <synthetic> val 17$y: Double = $$20.y;
          <synthetic> val arg$p1$x$18: Double = 17$x;
          <synthetic> val arg$p1$y$19: Double = 17$y;
          identity2mono(arg$p1$x$18, arg$p1$y$19)
        };
        <synthetic> val p4$x: Double = $$16.x;
        <synthetic> val p4$y: Double = $$16.y;
        <synthetic> var p5$x: Double = 3.0;
        <synthetic> var p5$y: Double = 3.1;
        p5$x = p2$x;
        p5$y = p2$y;
        new valium.testcases.multipoly.Point[Double](p2$x, p2$y)
      };
      def identitypoly[T](p1$x: T, p1$y: T): valium.testcases.multipoly.Point[T] = {
        <synthetic> val p2$x: T = p1$x;
        <synthetic> val p2$y: T = p1$y;
        def p3(): valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[T](p2$x, p2$y);
        scala.this.Predef.println(new valium.testcases.multipoly.Point[T](p2$x, p2$y));
        scala.this.Predef.println(Point.this.toString$xtension[T](p2$x, p2$y));
        <synthetic> val $$23: valium.testcases.multipoly.Point[T] = {
          <synthetic> val $$27: valium.testcases.multipoly.Point[T] = p3();
          <synthetic> val 24$x: T = $$27.x;
          <synthetic> val 24$y: T = $$27.y;
          <synthetic> val arg$p1$x$25: T = 24$x;
          <synthetic> val arg$p1$y$26: T = 24$y;
          identity2poly[T](arg$p1$x$25, arg$p1$y$26)
        };
        <synthetic> val p4$x: T = $$23.x;
        <synthetic> val p4$y: T = $$23.y;
        <synthetic> var $$28: valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[Double](3.0, 3.1).asInstanceOf[valium.testcases.multipoly.Point[T]]();
        <synthetic> var p5$x: T = $$28.x;
        <synthetic> var p5$y: T = $$28.y;
        p5$x = p2$x;
        p5$y = p2$y;
        new valium.testcases.multipoly.Point[T](p2$x, p2$y)
      };
      def identity2mono(p1$x: Double, p1$y: Double): valium.testcases.multipoly.Point[Double] = {
        case class C1 extends Object with Product with Serializable {
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$x: Double = _;
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$y: Double = _;
          <stable> <caseaccessor> <accessor> <paramaccessor> def p2(): valium.testcases.multipoly.Point[Double] = new valium.testcases.multipoly.Point[Double](C1.this.p2$x, C1.this.p2$y);
          def <init>(p2$x: Double, p2$y: Double): C1 = {
            C1.super.<init>();
            ()
          };
          <synthetic> def copy(p2$x: Double, p2$y: Double): C1 = new C1(p2$x, p2$y);
          <synthetic> def copy$default$1(): valium.testcases.multipoly.Point[Double] = C1.this.p2();
          override <synthetic> def productPrefix(): String = "C1";
          <synthetic> def productArity(): Int = 1;
          <synthetic> def productElement(x$1: Int): Any = {
            case <synthetic> val x1: Int = x$1;
            x1 match {
              case 0 => C1.this.p2()
              case _ => throw new IndexOutOfBoundsException(x$1.toString())
            }
          };
          override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C1.this);
          <synthetic> def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[C1]();
          override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C1.this);
          override <synthetic> def toString(): String = ScalaRunTime.this._toString(C1.this);
          override <synthetic> def equals(x$1: Any): Boolean = C1.this.eq(x$1.asInstanceOf[Object]()).||({
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[C1]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&({
            <synthetic> val C1$1: C1 = x$1.asInstanceOf[C1]();
            C1.this.p2().==(C1$1.p2()).&&(C1$1.canEqual(C1.this))
          }))
        };
        <synthetic> object C1 extends scala.runtime.AbstractFunction1[valium.testcases.multipoly.Point[Double],C1] with Serializable {
          def <init>(): C1.type = {
            C1.super.<init>();
            ()
          };
          final override <synthetic> def toString(): String = "C1";
          case <synthetic> def apply(p2$x: Double, p2$y: Double): C1 = new C1(p2$x, p2$y);
          @scala.annotation.bridge case <synthetic> def apply(@scala.annotation.bridge v1: valium.testcases.multipoly.Point[Double]): C1 = {
            <synthetic> val $$36: valium.testcases.multipoly.Point[Double] = v1;
            <synthetic> val 33$x: Double = $$36.x;
            <synthetic> val 33$y: Double = $$36.y;
            <synthetic> val arg$p2$x$34: Double = 33$x;
            <synthetic> val arg$p2$y$35: Double = 33$y;
            apply(arg$p2$x$34, arg$p2$y$35)
          };
          case <synthetic> def unapply(x$0: C1): Option[valium.testcases.multipoly.Point[Double]] = if (x$0.==(null))
            scala.this.None
          else
            new Some[valium.testcases.multipoly.Point[Double]](x$0.p2());
          <synthetic> private def readResolve(): Object = C1()
        };
        @volatile var C1$module: C1.type = _;
        <synthetic> <stable> def C1(): C1.type = {
          C1$module = new C1.type();
          C1$module
        };
        C1().apply(p1$x, p1$y).p2()
      };
      def identity2poly[T](p1$x: T, p1$y: T): valium.testcases.multipoly.Point[T] = {
        case class C11[T] extends Object with Product with Serializable {
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$x: T = _;
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$y: T = _;
          <stable> <caseaccessor> <accessor> <paramaccessor> def p2(): valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[T](C11.this.p2$x, C11.this.p2$y);
          def <init>(p2$x: T, p2$y: T): C11[T] = {
            C11.super.<init>();
            ()
          };
          <synthetic> def copy[T](p2$x: T, p2$y: T): C11[T] = new C11[T](p2$x, p2$y);
          <synthetic> def copy$default$1[T](): valium.testcases.multipoly.Point[T] = C11.this.p2();
          override <synthetic> def productPrefix(): String = "C11";
          <synthetic> def productArity(): Int = 1;
          <synthetic> def productElement(x$1: Int): Any = {
            case <synthetic> val x1: Int = x$1;
            x1 match {
              case 0 => C11.this.p2()
              case _ => throw new IndexOutOfBoundsException(x$1.toString())
            }
          };
          override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C11.this);
          <synthetic> def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[C11[_]]();
          override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C11.this);
          override <synthetic> def toString(): String = ScalaRunTime.this._toString(C11.this);
          override <synthetic> def equals(x$1: Any): Boolean = C11.this.eq(x$1.asInstanceOf[Object]()).||({
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[C11[T]]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&({
            <synthetic> val C11$1: C11[T] = x$1.asInstanceOf[C11[T]]();
            C11.this.p2().==(C11$1.p2()).&&(C11$1.canEqual(C11.this))
          }))
        };
        <synthetic> object C11 extends Object with Serializable {
          def <init>(): C11.type = {
            C11.super.<init>();
            ()
          };
          final override <synthetic> def toString(): String = "C11";
          case <synthetic> def apply[T](p2$x: T, p2$y: T): C11[T] = new C11[T](p2$x, p2$y);
          case <synthetic> def unapply[T](x$0: C11[T]): Option[valium.testcases.multipoly.Point[T]] = if (x$0.==(null))
            scala.this.None
          else
            new Some[valium.testcases.multipoly.Point[T]](x$0.p2());
          <synthetic> private def readResolve(): Object = C11()
        };
        @volatile var C11$module: C11.type = _;
        <synthetic> <stable> def C11(): C11.type = {
          C11$module = new C11.type();
          C11$module
        };
        case class C12 extends Object with Product with Serializable {
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$x: T = _;
          <synthetic> <caseaccessor> <paramaccessor> private[this] val p2$y: T = _;
          <stable> <caseaccessor> <accessor> <paramaccessor> def p2(): valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[T](C12.this.p2$x, C12.this.p2$y);
          def <init>(p2$x: T, p2$y: T): C12 = {
            C12.super.<init>();
            ()
          };
          <synthetic> def copy(p2$x: T, p2$y: T): C12 = new C12(p2$x, p2$y);
          <synthetic> def copy$default$1(): valium.testcases.multipoly.Point[T] = C12.this.p2();
          override <synthetic> def productPrefix(): String = "C12";
          <synthetic> def productArity(): Int = 1;
          <synthetic> def productElement(x$1: Int): Any = {
            case <synthetic> val x1: Int = x$1;
            x1 match {
              case 0 => C12.this.p2()
              case _ => throw new IndexOutOfBoundsException(x$1.toString())
            }
          };
          override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C12.this);
          <synthetic> def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[C12]();
          override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C12.this);
          override <synthetic> def toString(): String = ScalaRunTime.this._toString(C12.this);
          override <synthetic> def equals(x$1: Any): Boolean = C12.this.eq(x$1.asInstanceOf[Object]()).||({
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[C12]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&({
            <synthetic> val C12$1: C12 = x$1.asInstanceOf[C12]();
            C12.this.p2().==(C12$1.p2()).&&(C12$1.canEqual(C12.this))
          }))
        };
        <synthetic> object C12 extends scala.runtime.AbstractFunction1[valium.testcases.multipoly.Point[T],C12] with Serializable {
          def <init>(): C12.type = {
            C12.super.<init>();
            ()
          };
          final override <synthetic> def toString(): String = "C12";
          case <synthetic> def apply(p2$x: T, p2$y: T): C12 = new C12(p2$x, p2$y);
          @scala.annotation.bridge case <synthetic> def apply(@scala.annotation.bridge v1: valium.testcases.multipoly.Point[T]): C12 = {
            <synthetic> val $$50: valium.testcases.multipoly.Point[T] = v1;
            <synthetic> val 47$x: T = $$50.x;
            <synthetic> val 47$y: T = $$50.y;
            <synthetic> val arg$p2$x$48: T = 47$x;
            <synthetic> val arg$p2$y$49: T = 47$y;
            apply(arg$p2$x$48, arg$p2$y$49)
          };
          case <synthetic> def unapply(x$0: C12): Option[valium.testcases.multipoly.Point[T]] = if (x$0.==(null))
            scala.this.None
          else
            new Some[valium.testcases.multipoly.Point[T]](x$0.p2());
          <synthetic> private def readResolve(): Object = C12()
        };
        @volatile var C12$module: C12.type = _;
        <synthetic> <stable> def C12(): C12.type = {
          C12$module = new C12.type();
          C12$module
        };
        C11().apply[T](p1$x, p1$y).p2();
        C12().apply(p1$x, p1$y).p2()
      };
      def identity3mono(p1$x: Double, p1$y: Double): valium.testcases.multipoly.Point[Double] = {
        class C2 extends Object {
          <synthetic> <paramaccessor> private[this] val p2$x: Double = _;
          <synthetic> <paramaccessor> private[this] val p2$y: Double = _;
          def <init>(p2$x: Double, p2$y: Double): C2 = {
            C2.super.<init>();
            ()
          };
          def y(): valium.testcases.multipoly.Point[Double] = new valium.testcases.multipoly.Point[Double](C2.this.p2$x, C2.this.p2$y)
        };
        new C2(p1$x, p1$y).y()
      };
      def identity3poly[T](p1$x: T, p1$y: T): valium.testcases.multipoly.Point[T] = {
        class C21[T] extends Object {
          <synthetic> <paramaccessor> private[this] val p2$x: T = _;
          <synthetic> <paramaccessor> private[this] val p2$y: T = _;
          def <init>(p2$x: T, p2$y: T): C21[T] = {
            C21.super.<init>();
            ()
          };
          def y(): valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[T](C21.this.p2$x, C21.this.p2$y)
        };
        class C22 extends Object {
          <synthetic> <paramaccessor> private[this] val p2$x: T = _;
          <synthetic> <paramaccessor> private[this] val p2$y: T = _;
          def <init>(p2$x: T, p2$y: T): C22 = {
            C22.super.<init>();
            ()
          };
          def y(): valium.testcases.multipoly.Point[T] = new valium.testcases.multipoly.Point[T](C22.this.p2$x, C22.this.p2$y)
        };
        new C21[T](p1$x, p1$y).y();
        new C22(p1$x, p1$y).y()
      };
      scala.this.Predef.println({
        <synthetic> val 61$x: Double = 1.0;
        <synthetic> val 61$y: Double = 1.1;
        <synthetic> val arg$p1$x$62: Double = 61$x;
        <synthetic> val arg$p1$y$63: Double = 61$y;
        identitymono(arg$p1$x$62, arg$p1$y$63)
      });
      scala.this.Predef.println({
        <synthetic> val 64$x: Double = 1.0;
        <synthetic> val 64$y: Double = 1.1;
        <synthetic> val arg$p1$x$65: Double = 64$x;
        <synthetic> val arg$p1$y$66: Double = 64$y;
        identitypoly[Double](arg$p1$x$65, arg$p1$y$66)
      });
      scala.this.Predef.println({
        <synthetic> val 67$x: Double = 2.0;
        <synthetic> val 67$y: Double = 2.1;
        <synthetic> val arg$p1$x$68: Double = 67$x;
        <synthetic> val arg$p1$y$69: Double = 67$y;
        identity2mono(arg$p1$x$68, arg$p1$y$69)
      });
      scala.this.Predef.println({
        <synthetic> val 70$x: Double = 2.0;
        <synthetic> val 70$y: Double = 2.1;
        <synthetic> val arg$p1$x$71: Double = 70$x;
        <synthetic> val arg$p1$y$72: Double = 70$y;
        identity2poly[Double](arg$p1$x$71, arg$p1$y$72)
      });
      scala.this.Predef.println({
        <synthetic> val 73$x: Double = 3.0;
        <synthetic> val 73$y: Double = 3.1;
        <synthetic> val arg$p1$x$74: Double = 73$x;
        <synthetic> val arg$p1$y$75: Double = 73$y;
        identity3mono(arg$p1$x$74, arg$p1$y$75)
      });
      scala.this.Predef.println({
        <synthetic> val 76$x: Double = 3.0;
        <synthetic> val 76$y: Double = 3.1;
        <synthetic> val arg$p1$x$77: Double = 76$x;
        <synthetic> val arg$p1$y$78: Double = 76$y;
        identity3poly[Double](arg$p1$x$77, arg$p1$y$78)
      })
    }
  }
}

[Now checking: valium-commit]