warning: 'valium' selects 6 phases
[Now checking: valium-prepare]
[Now checking: valium-verify]
[Now checking: valium-addext]
[Now checking: valium-inject]
[Not checkable: valium-coerce]
[[syntax trees at end of             valium-commit]] // newSource1.scala
package valium.testcases.multibridge {
  @value final class C extends Object {
    <paramaccessor> private[this] val x1: Int = _;
    <stable> <accessor> <paramaccessor> def x1(): Int = C.this.x1;
    <paramaccessor> private[this] val x2: Int = _;
    <stable> <accessor> <paramaccessor> def x2(): Int = C.this.x2;
    def <init>(x1: Int, x2: Int): valium.testcases.multibridge.C = {
      C.super.<init>();
      ()
    };
    override def toString(): String = {
      <synthetic> val $2: valium.testcases.multibridge.C = C.this;
      <synthetic> val $1$x1: Int = $2.x1;
      <synthetic> val $1$x2: Int = $2.x2;
      <synthetic> val this$x1: Int = $1$x1;
      <synthetic> val this$x2: Int = $1$x2;
      multibridge.this.C.toString$xtension(this$x1, this$x2)
    };
    override <synthetic> def equals(x$1: Any): Boolean = {
      <synthetic> val $4: valium.testcases.multibridge.C = C.this;
      <synthetic> val $3$x1: Int = $4.x1;
      <synthetic> val $3$x2: Int = $4.x2;
      <synthetic> val this$x1: Int = $3$x1;
      <synthetic> val this$x2: Int = $3$x2;
      <synthetic> val : Any = x$1;
      multibridge.this.C.equals$xtension(this$x1, this$x2, )
    };
    override <synthetic> def hashCode(): Int = {
      <synthetic> val $6: valium.testcases.multibridge.C = C.this;
      <synthetic> val $5$x1: Int = $6.x1;
      <synthetic> val $5$x2: Int = $6.x2;
      <synthetic> val this$x1: Int = $5$x1;
      <synthetic> val this$x2: Int = $5$x2;
      multibridge.this.C.hashCode$xtension(this$x1, this$x2)
    }
  };
  <synthetic> object C extends Object {
    def <init>(): valium.testcases.multibridge.C.type = {
      C.super.<init>();
      ()
    };
    final def toString$xtension($this$x1: Int, $this$x2: Int): String = new StringContext(scala.this.Predef.wrapRefArray[String](Array[String]{"C(", ", ", ")"})).s(scala.this.Predef.genericWrapArray[Any](Array[Any]{$this$x1, $this$x2}));
    final <synthetic> def equals$xtension($this$x1: Int, $this$x2: Int, x$1: Any): Boolean = x$1.isInstanceOf[valium.testcases.multibridge.C]().&&({
      <synthetic> val $7: valium.testcases.multibridge.C = x$1.asInstanceOf[valium.testcases.multibridge.C]();
      <synthetic> val C$1$x1: Int = $7.x1;
      <synthetic> val C$1$x2: Int = $7.x2;
      $this$x1.==(C$1$x1).&&($this$x2.==(C$1$x2))
    });
    final <synthetic> def hashCode$xtension($this$x1: Int, $this$x2: Int): Int = 67.+($this$x1.hashCode()).+($this$x2.hashCode())
  };
  abstract trait Foo[X] extends Object {
    def foo(foox: X, fooy$x1: Int, fooy$x2: Int): X
  };
  abstract trait Bar[Y] extends Object {
    def foo(barx$x1: Int, barx$x2: Int, bary: Y): Y
  };
  abstract trait IntForC extends Object {
    def foo(forcx$x1: Int, forcx$x2: Int, forcy$x1: Int, forcy$x2: Int): valium.testcases.multibridge.C
  };
  class FooForC extends Object with valium.testcases.multibridge.Foo[valium.testcases.multibridge.C] with valium.testcases.multibridge.Bar[valium.testcases.multibridge.C] with valium.testcases.multibridge.IntForC {
    def <init>(): valium.testcases.multibridge.FooForC = {
      FooForC.super.<init>();
      ()
    };
    override def foo(x$x1: Int, x$x2: Int, y$x1: Int, y$x2: Int): valium.testcases.multibridge.C = {
      scala.this.Predef.println(new StringContext(scala.this.Predef.wrapRefArray[String](Array[String]{"", ", ", ""})).s(scala.this.Predef.genericWrapArray[Any](Array[Any]{new valium.testcases.multibridge.C(x$x1, x$x2), new valium.testcases.multibridge.C(y$x1, y$x2)})));
      new valium.testcases.multibridge.C(x$x1, x$x2)
    };
    @scala.annotation.bridge override def foo(barx$x1: Int, barx$x2: Int, @scala.annotation.bridge bary: valium.testcases.multibridge.C): valium.testcases.multibridge.C = {
      <synthetic> val arg$x$x1: Int = barx$x1;
      <synthetic> val arg$x$x2: Int = barx$x2;
      <synthetic> val $9: valium.testcases.multibridge.C = bary;
      <synthetic> val $8$x1: Int = $9.x1;
      <synthetic> val $8$x2: Int = $9.x2;
      <synthetic> val arg$y$x1: Int = $8$x1;
      <synthetic> val arg$y$x2: Int = $8$x2;
      foo(arg$x$x1, arg$x$x2, arg$y$x1, arg$y$x2)
    };
    @scala.annotation.bridge override def foo(@scala.annotation.bridge foox: valium.testcases.multibridge.C, fooy$x1: Int, fooy$x2: Int): valium.testcases.multibridge.C = {
      <synthetic> val $11: valium.testcases.multibridge.C = foox;
      <synthetic> val $10$x1: Int = $11.x1;
      <synthetic> val $10$x2: Int = $11.x2;
      <synthetic> val arg$x$x1: Int = $10$x1;
      <synthetic> val arg$x$x2: Int = $10$x2;
      <synthetic> val arg$y$x1: Int = fooy$x1;
      <synthetic> val arg$y$x2: Int = fooy$x2;
      foo(arg$x$x1, arg$x$x2, arg$y$x1, arg$y$x2)
    }
  };
  object Test extends Object {
    def <init>(): valium.testcases.multibridge.Test.type = {
      Test.super.<init>();
      ()
    };
    def main(args: Array[String]): Unit = {
      <synthetic> val : valium.testcases.multibridge.C = new valium.testcases.multibridge.C(0, 1);
      <synthetic> val $12$x1: Int = 1;
      <synthetic> val $12$x2: Int = 2;
      <synthetic> val arg$fooy$x1: Int = $12$x1;
      <synthetic> val arg$fooy$x2: Int = $12$x2;
      (new valium.testcases.multibridge.FooForC(): valium.testcases.multibridge.Foo[valium.testcases.multibridge.C]).foo(, arg$fooy$x1, arg$fooy$x2);
      <synthetic> val $13$x1: Int = 2;
      <synthetic> val $13$x2: Int = 3;
      <synthetic> val arg|x$x1: Int = $13$x1;
      <synthetic> val arg|x$x2: Int = $13$x2;
      <synthetic> val : valium.testcases.multibridge.C = new valium.testcases.multibridge.C(3, 4);
      (new valium.testcases.multibridge.FooForC(): valium.testcases.multibridge.Bar[valium.testcases.multibridge.C]).foo(arg|x$x1, arg|x$x2, );
      <synthetic> val $14$x1: Int = 4;
      <synthetic> val $14$x2: Int = 5;
      <synthetic> val arg$forcx$x1: Int = $14$x1;
      <synthetic> val arg$forcx$x2: Int = $14$x2;
      <synthetic> val $15$x1: Int = 5;
      <synthetic> val $15$x2: Int = 6;
      <synthetic> val arg$forcy$x1: Int = $15$x1;
      <synthetic> val arg$forcy$x2: Int = $15$x2;
      (new valium.testcases.multibridge.FooForC(): valium.testcases.multibridge.IntForC).foo(arg$forcx$x1, arg$forcx$x2, arg$forcy$x1, arg$forcy$x2);
      {
        <synthetic> val $16$x1: Int = 6;
        <synthetic> val $16$x2: Int = 7;
        <synthetic> val arg$x$x1: Int = $16$x1;
        <synthetic> val arg$x$x2: Int = $16$x2;
        <synthetic> val $17$x1: Int = 7;
        <synthetic> val $17$x2: Int = 8;
        <synthetic> val arg$y$x1: Int = $17$x1;
        <synthetic> val arg$y$x2: Int = $17$x2;
        new valium.testcases.multibridge.FooForC().foo(arg$x$x1, arg$x$x2, arg$y$x1, arg$y$x2);
        ()
      }
    }
  }
}

[Now checking: valium-commit]